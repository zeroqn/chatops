name: Integration test from PR
# Triggered use /itest comment from pr

on:
  issue_comment:
    types: [created]

jobs:
  pr-info:
    if: github.event.issue.pull_request && startsWith(github.event.comment.body, '/itest')
    runs-on: ubuntu-20.04
    steps:
      - name: Query author repository permissions
        uses: octokit/request-action@v2.x
        id: user_permission
        with:
          route: GET /repos/${{ github.repository }}/collaborators/${{ github.event.sender.login }}/permission
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # restrict /itest to users with admin or write permission
      # see https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#get-repository-permissions-for-a-user
      - name: Check if user does have correct permissions
        if: contains('admin write', fromJson(steps.user_permission.outputs.data).permission)
        id: check_user_perm
        run: |
          echo "User '${{ github.event.sender.login }}' has permission '${{ fromJson(steps.user_permission.outputs.data).permission }}' allowed values: 'admin', 'write'"
          echo "::set-output name=allowed_user::true"
    outputs:
      allowed_user: ${{ steps.check_user_perm.outputs.allowed_user }}

  component-info:
    needs: pr-info
    if: needs.pr-info.outputs.allowed_user == 'true' && github.event.issue.pull_request && startsWith(github.event.comment.body, '/itest')
    runs-on: ubuntu-20.04
    outputs:
      components_info: ${{ steps.get_components.outputs.result }}
    steps:
      - uses: actions/github-script@v6
        id: get_components
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        with:
          script: |
            const {COMMENT_BODY} = process.env
            core.info(`comment body ${COMMENT_BODY}`);

            const getPrebuilds = async (org, page, perPage) => {
              return await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                package_type: "container",
                package_name: "godwoken-prebuilds",
                org,
                page,
                per_page: perPage,
              });
            };

            const getPrebuildsByTag = async (org, tag) => {
              const pkgs = await getPrebuilds(org, 1, 100);
              for (const pkg of pkgs.data) {
                if (pkg.metadata.container.tags.includes(tag)) {
                  return pkg;
                }
              }
            };

            // Parse commentBody
            const prebuilds = {
              org: "nervosnetwork",
              repo: "godwoken-docker-prebuilds",
              pattern: /prebuilds: (.*)/,
              packageType: "container",
              packageName: "godwoken-prebuilds",
              tags: undefined,
              sha: undefined,
              htmlUrl: undefined,
              manifest: {
                godwoken: {
                  pattern: /&quot;ref.component.godwoken-sha1&quot;: &quot;(.{40})&quot;,/,
                  sha: undefined,
                },
                scripts: {
                  pattern: /&quot;ref.component.godwoken-scripts-sha1&quot;: &quot;(.{40})&quot;,/,
                  sha: undefined,
                },
                polyjuice: {
                  pattern: /&quot;ref.component.godwoken-polyjuice-sha1&quot;: &quot;(.{40})&quot;,/,
                  sha: undefined,
                },
              },
            };
            const components = {
              godwoken: {
                owner: "nervosnetwork",
                repo: "godwoken",
                branch: "compatibility-breaking-changes",
                pattern: /godwoken: (.*)/,
                commit: undefined,
                htmlUrl: undefined,
                branchOrCommit: undefined,
              },
              scripts: {
                owner: "nervosnetwork",
                repo: "godwoken-scripts",
                branch: "compatibility-breaking-changes",
                pattern: /scripts: (.*)/,
                commit: undefined,
                htmlUrl: undefined,
                branchOrCommit: undefined,
              },
              polyjuice: {
                owner: "nervosnetwork",
                repo: "godwoken-polyjuice",
                branch: "compatibility-breaking-changes",
                pattern: /polyjuice: (.*)/,
                commit: undefined,
                htmlUrl: undefined,
                branchOrCommit: undefined,
              },
              web3: {
                owner: "nervosnetwork",
                repo: "godwoken-web3",
                branch: "compatibility-breaking-changes",
                pattern: /web3: (.*)/,
                commit: undefined,
                htmlUrl: undefined,
                branchOrCommit: undefined,
              },
              kicker: {
                owner: "RetricSu",
                repo: "godwoken-kicker",
                branch: "compatibility-changes",
                pattern: /kicker: (.*)/,
                commit: undefined,
                htmlUrl: undefined,
                branchOrCommit: undefined,
              },
            };

            // Fetch pr commit
            const pr = (
              await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
              })
            ).data.head;
            core.info(`${JSON.stringify(pr.ref)}`);
            core.info(`${JSON.stringify(pr.repo.name)}`);

            // Fetch prebuilds
            const matchPrebuilds = async () => {
              const match = prebuilds.pattern.exec(`${COMMENT_BODY}`);
              if (match) {
                return await getPrebuildsByTag(prebuilds.org, match[1]);
              } else {
                return (await getPrebuilds(prebuilds.org, 1, 2)).data[0];
              }
            };
            const pkg = await matchPrebuilds();

            prebuilds.tags = pkg.metadata.container.tags;
            prebuilds.htmlUrl = pkg.html_url;
            prebuilds.sha = pkg.name;
            core.info(`pkg: ${JSON.stringify(pkg)}`);

            // Fetch prebuilds components commit;
            const manifestPage = JSON.stringify(
              await github.request(`GET ${prebuilds.htmlUrl}`)
            );
            for (const name in prebuilds.manifest) {
              const label = prebuilds.manifest[name];
              const match = label.pattern.exec(manifestPage);
              if (match) {
                label.sha = match[1];
              } else {
                throw `${name}-sha1 not found`;
              }
            }
            core.info(`${JSON.stringify(prebuilds)}`);

            for (const name in components) {
              const comp = components[name];

              // Ref from pr is priority
              if (pr.repo.name === comp.repo) {
                comp.branchOrCommit = pr.sha;
                continue;
              }

              const match = comp.pattern.exec(`${COMMENT_BODY}`);
              if (match) {
                comp.branchOrCommit = match[1];
              } else if (prebuilds.manifest[name]) {
                comp.branchOrCommit = prebuilds.manifest[name].sha;
              } else {
                if (name === "web3") {
                  continue;
                }
                comp.branchOrCommit = comp.branch;
              }
            }
            core.info(JSON.stringify(components));

            // Fetch branch/commit sha and html url
            for (const name in components) {
              const comp = components[name];
              core.info(`fetch branch or commit ${name}`);

              if (comp.branchOrCommit === undefined) {
                core.info(`skip fetch component info ${name}`);
                continue;
              }

              try {
                // Try branch
                const resp = await github.rest.repos.getBranch({
                  owner: comp.owner,
                  repo: comp.repo,
                  branch: comp.branchOrCommit,
                });
                comp.commit = resp.data.commit.sha;
                comp.htmlUrl = resp.data.commit.html_url;
              } catch {
                core.info(`${comp.branchOrCommit} branch not found`);
              }

              try {
                if (comp.commit === undefined) {
                  // Try commit
                  const resp = await github.rest.git.getCommit({
                    owner: comp.owner,
                    repo: comp.repo,
                    commit_sha: comp.branchOrCommit,
                  });
                  comp.commit = resp.data.sha;
                  comp.htmlUrl = resp.data.html_url;
                }
              } catch {
                core.info(`${comp.branchOrCommit} full commit not found`);
              }

              try {
                if (comp.commit === undefined) {
                  // Try serach commits
                  const resp = await github.rest.repos.listCommits({
                    owner: comp.owner,
                    repo: comp.repo,
                    sha: comp.branchOrCommit,
                    per_page: 1,
                    page: 1,
                  });
                  if (resp.data[0].sha.startsWith(comp.branchOrCommit)) {
                    comp.commit = resp.data[0].sha;
                    comp.htmlUrl = resp.data[0].html_url;
                  } else {
                    throw `${comp.branchOrCommit} short sha commit not found`;
                  }
                }
              } catch {
                core.error(`${comp.branchOrCommit} short commit not found`);
              }

              if (comp.commit === undefined) {
                throw `${comp.branchOrCommit} not found`;
              }
            }
            core.info(JSON.stringify(components));
            return {prebuilds, components};

      - name: Write a comment on the PR with component commits
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const components_info = JSON.parse(`${{ steps.get_components.outputs.result }}`);
            const prebuilds = components_info.prebuilds;
            const components = components_info.components;

            // Post integration test info
            let comment_body = `
            Run integration test with following specific components:

            prebuilds: [${prebuilds.tags}](${prebuilds.htmlUrl})
            `;
            for (const name in components) {
              const comp = components[name];
              if (comp.commit === undefined) {
                continue;
              }
              const shortSha = comp.commit.substr(0, 7);
              componentInfo = `${componentInfo}\n${name}: [${shortSha}](${comp.htmlUrl})`;
            }
            core.info(`${componentInfo}`);

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment_body,
            })

  integration-test:
    needs: component-info
    if: github.event.issue.pull_request && startsWith(github.event.comment.body, '/itest')
    uses: nervosnetwork/godwoken-tests/.github/workflows/reusable-integration-test-v1.yml@develop
    with:
      # github.head_ref: The head_ref or source branch of the pull request in a workflow run. This property is only available when the event that triggers a workflow run is either pull_request or pull_request_target.
      # github.ref: The branch or tag ref that triggered the workflow run. For branches this is the format refs/heads/<branch_name>, and for tags it is refs/tags/<tag_name>.
      kicker_ref: ${{ fromJSON(needs.component-info.outputs.components_info).components.kicker.commit }}
      gw_prebuild_image_tag: ${{ fromJSON(needs.component-info.outputs.components_info).prebuilds.tags[0] }}
      godwoken_ref: ${{ fromJSON(needs.component-info.outputs.components_info).components.godwoken.commit }}
      gw_scripts_ref: ${{ fromJSON(needs.component-info.outputs.components_info).components.scripts.commit }}
      polyjuice_ref: ${{ fromJSON(needs.component-info.outputs.components_info).components.polyjuice.commit }}
      web3_ref: ${{ fromJSON(needs.component-info.outputs.components_info).components.web3.commit }}
